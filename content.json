{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/23/hello-world/"},{"title":"Golang zap 日志框架","text":"","link":"/2021/08/28/Golang-zap-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"},{"title":"构造过程抽象","text":"设计良好的计算机系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分可以独立地构造、替换、排除错误。 过程作为黑箱抽象，目的是隐藏过程定义的细节 牛顿发求x的平方根，首先猜测一个数y，计算出 y和x/y的平均值z，直到 z * z无限接近x即可 1234567891011121314151617181920212223#lang Racket(define (square x) (* x x))(define (abs x) (if (&lt; x 0) (- x) x))(define (average x y) (/ (+ x y) 2))(define (sqrt x) (define (good-enough? guess) (&lt; (abs (- (square guess) x )) 0.001)) (define (improve guess) (average guess (/ x guess))) (define (sqrt-iter guess) (if (good-enough? guess) guess (sqrt-iter (improve guess)))) (sqrt-iter 1.0)) sqrt 方法隐藏了内部实现细节，这就是过程抽象 计算过程 递归计算过程，以n的阶乘为例 123456789101112131415161718(define (factorial n) (if (= n 1) 1 (* n (factorial(- n 1))))) # 5的阶乘的计算过程如下： （factorail 5）(* 5 (factorial 4))(* 5 (* 4 (factorial 3)))(* 5 (* 4 (* 3 (factorial 2))))(* 5 (* 4 (* 3 (* 2 factorial 1)))))(* 5 (* 4 (* 3 (* 2 1)))))(* 5 (* 4 (* 3 2)))(* 5 (* 4 6))(* 5 24)120这一计算过程有一个推迟计算的链条刻画，称为递归计算过程。需要维护的信息多 1234567891011121314151617181920(define (factorial n) (fact-iter 1 1 n))(define (fact-iter product counter max-count)(if (&gt; counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))) # 5的阶乘的计算过程如下： （factorail 5） (fact-iter 1 1 5)(fact-iter 1 2 5)(fact-iter 2 3 5)(fact-iter 6 4 5)(fact-iter 24 5 5)(fact-iter 120 6 5)这一计算过程由三个固定变量刻画，只需要维护三个变量的轨迹即可。这一计算过程成为迭代计算过程。也称为尾递归 高阶函数抽象，以过程作为参数或者返回值的操作称为高阶过程 lambda，可以用lambda构造一些简单的过程，如(lambda (x) (+ x 4)) 函数的不动点，如果x满足f(x) = x,则称x为函数f的不动点 1234567891011121314(define (abs x) (if (&lt; x 0) (- x) x))(define (fixed-point f first-guess) (define (close-enough? v1 v2) (&lt; (abs (- v1 v2)) 0.00001)) (define (try guess) (let ((next (f guess))) (if (close-enough? guess next) next (try next)))) (try first-guess))","link":"/2021/09/11/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1/"}],"tags":[{"name":"sicp","slug":"sicp","link":"/tags/sicp/"},{"name":"抽象","slug":"抽象","link":"/tags/%E6%8A%BD%E8%B1%A1/"}],"categories":[]}